#version 460

//
// this part isnt my code its a psuedo random number generator I stole off the internet
// if this breaks it isnt my fault
//

#define PI 3.1415926535897932385
#define TAU 2. * PI
#define PHI 1.61803398874989484820459
#define INFINITY 1 / 0

float seed = 0.25;

// random number generator stolen from stack overflow
//https://stackoverflow.com/a/34276128

// a variation of gold noise is used
// https://stackoverflow.com/a/28095165
// https://www.shadertoy.com/view/ltB3zD
// centered around [0-1] in gaussian

float Random (vec2 st) {
    return fract(tan(distance(st*PHI, st)*seed)*st.x);
}

vec2 Random2(float seed){
    return vec2(Random(vec2(seed-1.23, (seed+3.1)* 3.2)), Random(vec2(seed+12.678, seed - 5.8324)));
}

vec3 Random3(float seed){
    return vec3(Random(vec2(seed-0.678, seed-0.123)), Random(vec2(seed-0.3, seed+0.56)), Random(vec2(seed+0.1234, seed-0.523)));
}

vec3 RandomInUnitSphere( float seed ) {
    vec2 tp = Random2(seed);
    float theta = tp.x * TAU;
    float phi = tp.y * TAU;
    vec3 p = vec3(sin(theta) * cos(phi), sin(theta)*sin(phi), cos(theta));

    return normalize(p);
}

vec3 RandomUnit(float seed){
    vec2 rand = Random2(seed);
    float a = rand.x * TAU;
    float z = (2. * rand.y) - 1.;
    float r = sqrt(1. - z*z);
    return vec3(r*cos(a), r*sin(a), z);
}

//
// my stuff again here
//

float degrees_to_radians(float degrees) {
    return degrees * PI / 180.0;
}

// mat 0 = lambertian
// mat 1 = metal
// mat 2 = dielectric

struct sphere {
    int material;
    float radius;
    float fuzz;
    float ri;
    vec3 center;
    vec3 albedo;
};

struct ray {
    vec3 origin;
    vec3 direction;
};

struct hitrecord {
    bool front_face;
    float t;
    vec3 p;
    vec3 normal;
    sphere s;
};

struct interval {
    float min;
    float max;
};

const interval EMPTY = interval(INFINITY, -INFINITY);
const interval UNIVERSE = interval(-INFINITY, INFINITY);

// number of samples for anti aliasing

const int SAMPLES = 4;

layout (local_size_x = 32, local_size_y = 32) in;
layout (rgba16f, set = 0, binding = 0) uniform image2D image;

layout (set = 0, binding = 1) uniform SimpleUBO {
    int num_spheres;
    float delta_time;
    float aspect_ratio;
    float focal_length;
    float viewport_width;
    float viewport_height;
    float vfov;
    vec3 camera_center;
    vec3 viewport_u;
    vec3 viewport_v;
    vec3 pixel_delta_u;
    vec3 pixel_delta_v;
    vec3 viewport_upper_left;
    vec3 pixel00_loc;
    vec3 look_from;
    vec3 look_at;
    vec3 vup;
} ubo;

layout (set = 0, binding = 2) readonly buffer SpheresSSBO {
    sphere spheres[];
} world;

vec3 ray_at(ray r, float t) {
    return r.origin + (t * r.direction);
}

float interval_size(interval i) {
    return i.max - i.min;
}

bool interval_contains(interval i, float x) {
    return i.min <= x && x <= i.max;
}

bool interval_surrounds(interval i, float x) {
    return i.min < x && x < i.max;
}

float interval_clamp(interval i, float x) {
    if (x < i.min) return i.min;
    if (x > i.max) return i.max;
    return x;
}

bool vec_near_zero(vec3 v) {
    float s = 1e-8;
    return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);
}

vec3 vec_reflect(vec3 v, vec3 n) {
    return v - 2*dot(v,n)*n;
}

vec3 vec_refract(vec3 v, vec3 uv, vec3 n, float etai_over_etat) {
    float cos_theta = min(dot(-uv, n), 1.0);
    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);
    vec3 r_out_parallel = sqrt(abs(1.0 - dot(r_out_perp, r_out_perp))) * n;
    return r_out_perp + r_out_parallel;
}

void lambertian_scatter(ray r, hitrecord rec, inout ray scattered) {
    vec3 jitter = RandomUnit(seed);
    if(isnan(jitter.r) || isnan(jitter.g) || isnan(jitter.b)){
        jitter = vec3(0.);
    }

    vec3 target = (rec.p + rec.normal + jitter);
    scattered.origin = rec.p;
    scattered.direction = normalize(target - rec.p);

    if (vec_near_zero(scattered.direction))
        scattered.direction = normalize(rec.normal);
}

bool metal_scatter(ray r, hitrecord rec, inout ray scattered) {
    vec3 reflected = normalize(reflect(r.direction, rec.normal)) + (rec.s.fuzz * RandomUnit(seed));
    scattered.origin = rec.p;
    scattered.direction = reflected;
    return dot(scattered.direction, rec.normal) > 0;
}

void dielectric_scatter(ray r, hitrecord rec, inout ray scattered) {

    float ri = rec.front_face ? (1.0 / rec.s.ri) : rec.s.ri;
    vec3 unit_direction = normalize(r.direction);

    float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

    bool cannot_refract = ri * sin_theta > 1.0;
    vec3 direction;

    if (cannot_refract)
        direction = reflect(unit_direction, rec.normal);
    else
        direction = refract(unit_direction, rec.normal, ri);

    scattered.origin = rec.p;
    scattered.direction = normalize(direction);
}

// bad math below
// basically, we solve for a quadratic equation where our ray intersects the sphere
// we use the discriminant (b^2 - 4ac in the quadratic eq) to solve for how many roots
// if discriminant is >= 0, real roots exists and an intersection occurs
// then we solve for normal vector
// technically that means that this only works for spheres and not planes, but ill figure that
// part out later

bool sphere_hit(sphere s, ray r, interval ray_t, inout hitrecord rec) {

    vec3 oc = r.origin - s.center;
    float a = dot(r.direction, r.direction);
    float h = dot(r.direction, oc);
    float c = dot(oc, oc) - (s.radius * s.radius);

    float discriminant = (h*h) - (a*c);
    if (discriminant < 0) {
        return false;
    }

    float sqrtd = sqrt(discriminant);

    float t1 = (-h - sqrtd);
    float t2 = (-h + sqrtd);
    float t = t1 < 0.05 ? t2 : t1;

    vec3 hit_point = ray_at(r, t);
    vec3 hit_normal = hit_point - s.center;

    bool frontFace = dot(r.direction, hit_normal) > 0.0;
    hit_normal = frontFace ? -hit_normal : hit_normal;
    hit_normal /= s.radius;

    if(!interval_surrounds(ray_t, t))
        return false;

    rec = hitrecord(frontFace, t, hit_point, hit_normal, s);

    return true;
}

// calculate all intersections for everything in the world

bool world_hit(ray r, interval ray_t, inout hitrecord rec) {
    bool has_hit_anything = false;
    for (uint i = 0; i < ubo.num_spheres; i++) {
        sphere s = world.spheres[i];
        has_hit_anything = sphere_hit(s, r, ray_t, rec) || has_hit_anything;
    }
    return has_hit_anything;
}

const int MAX_DEPTH = 5;

vec3 ray_color(ray r) {

    hitrecord rec;
    vec3 col = vec3(1.0);

    for(int i = 0; i < MAX_DEPTH; i++) {
        bool hit = world_hit(r, interval(0.001, INFINITY), rec);

        if(hit) {

            ray scattered;

            if (rec.s.material == 0) {
                lambertian_scatter(r, rec, scattered);
                col *= rec.s.albedo;

                r.origin = scattered.origin;
                r.direction = scattered.direction;
            } else if (rec.s.material == 1) {
                if (metal_scatter(r, rec, scattered)) {
                    col *= rec.s.albedo;

                    r.origin = scattered.origin;
                    r.direction = scattered.direction;
                } else {
                    col *= vec3(0);
                    break;
                }
            } else if (rec.s.material == 2) {
                dielectric_scatter(r, rec, scattered);
                r.origin = scattered.origin;
                r.direction = scattered.direction;
            }

        } else {
            vec3 dir = normalize(r.direction);
            float t = 0.5 * (dir.y + 1.0);
            col *= mix(vec3(1.0), vec3(0.5, 0.7, 0.8), t);
            return col;
        }
    }

    return col;
}

ray get_ray(float i, float j) {

    // shitty MSAA implementation
    // wow this sucks more than I thought it would

    vec3 jitter = RandomUnit(seed);
    if(isnan(jitter.x) || isnan(jitter.y)){
        jitter = vec3(0.);
    }

    vec3 pixel_sample = ubo.pixel00_loc + ((i + jitter.x) * ubo.pixel_delta_u) + ((j + jitter.y) * ubo.pixel_delta_v);

    vec3 ray_origin = ubo.camera_center;
    vec3 ray_direction = normalize(pixel_sample - ray_origin);

    return ray(ray_origin, ray_direction);
}

vec4 post_processing(vec3 color) {

    // color clamp to correct for over exposure

    interval color_interval = interval(0.0, 0.99999);

    color.x = interval_clamp(color_interval, color.x);
    color.y = interval_clamp(color_interval, color.y);
    color.z = interval_clamp(color_interval, color.z);

    return vec4(color, 1.0);
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

    float i = float(texelCoord.x);
    float j = float(texelCoord.y);

    seed = Random(gl_GlobalInvocationID.xy * (mod(ubo.delta_time, 100.)));

    vec3 pixelcolor = vec3(0, 0, 0);
    for (int k = 0; k < SAMPLES; k++) {
        ray r = get_ray(i, j);
        pixelcolor += ray_color(r);
    }

    pixelcolor *= 1 / float(SAMPLES);
    imageStore(image, texelCoord, post_processing(pixelcolor));
}